<!DOCTYPE html>
<html>
  <head>
		<meta charset="utf-8">
		<title>d3</title>
<script src="d3.v3.min.js"></script>
<script src="../js/jquery-1.7.2.js"></script>
<script src="../js/util.js"></script>  
<style type="text/css">  
polyline{
	opacity: 0;
	stroke: #666;
	stroke-width: 2px;
	fill: none;
}
</style> 
</head>
<body>  
<script type="text/javascript">  
var dataset=[5,10,20,40,6,25].sort();  
//(1)转化数据为适合生成饼图的对象数组  
var pie=d3.layout.pie(dataset);  
  
var h=600;  
var w=800;  
  
var outerRadius=w/5;//外半径  
//(7)圆环内半径  
var innerRadius=w/5;  
var radius = Math.min(w, h) / 2;
//(2)用svg的path绘制弧形的内置方法  设置弧度的内外径，等待传入的数据生成弧度  
var arc=d3.svg.arc()
.outerRadius(outerRadius*0.6)
.innerRadius(innerRadius*0.6);
//设置动画效果内外半径
var arc2=d3.svg.arc()
.outerRadius(outerRadius*0.8)
.innerRadius(innerRadius*0.6);

var outerArc = d3.svg.arc()
.innerRadius(outerRadius * 0.95)
.outerRadius(outerRadius * 0.95);

var svg=d3.select("body").append("svg").attr("width",w).attr("height",h);
        
//(3)颜色函数  
var color=d3.scale.category10();//创建序数比例尺和包括10中颜色的输出范围  
//(4)准备分组,把每个分组移到图表中心  
var arcs=svg.selectAll("g.arc")
.data(pie(dataset))
.enter()
.append("g")
.attr("class","arc")
//移到图表中心
.attr("transform","translate("+w / 2+","+h / 2+")");//translate(a,b)a表示横坐标起点，b表示纵坐标起点  

//(5)为组中每个元素绘制弧形路路径  
arcs.append("path")//每个g元素都追加一个path元素用绑定到这个g的数据d生成路径信息   
.attr("fill",function(d,i){//填充颜色  
    return color(i);  
})
.each(function() { this._current = {startAngle: 0, endAngle: 0}; });
//.attr("d",arc);//将角度转为弧度（d3使用弧度绘制）  

//实现饼图每块依次弹出
d3.selectAll("path")
.transition()
.delay(function(d,i){
	return  i/dataset.length*1000;
})
.duration(1000)
.ease("linear")
.attrTween("d", function(d) {
	var interpolate = d3.interpolate(this._current, d);
	this._current = interpolate(0);
	return function(t) {
		return arc2(interpolate(t));
	};
});
//attr("d",arc2);

  
//(6)为组中每个元素添加文本  
arcs.append("text")//每个g元素都追加一个path元素用绑定到这个g的数据d生成路径信息  
.attr("transform",function(d){
    return "translate("+arc2.centroid(d)+")";//计算每个弧形的中心点（几何中心）  
})
.attr("text-anchor","middle")
.text(function(d){
    return d.value;//这里已经转为对象了  
});

svg.append("g").attr("class", "labels").attr("transform","translate("+w / 2+","+h / 2+")");
var key = function(d){ return d.data; };
var text = svg.select(".labels").selectAll("text").data(pie(dataset), key);

text.enter()
  .append("text")
  .attr("dy", "0.35em")
  .text(function(d) {
    return d.data+"  "+d.value;
  });

text.transition().duration(1000)
  .attrTween("transform", function(d) {
    this._current = this._current || d;
    var interpolate = d3.interpolate(this._current, d);
    this._current = interpolate(0);
    return function(t) {
      var d2 = interpolate(t);
      var pos = outerArc.centroid(d2);
      pos[0] = radius/2* (midAngle(d2) < Math.PI ? 1 : -1);
      return "translate("+ pos +")";
    };
  })
  .styleTween("text-anchor", function(d){
    this._current = this._current || d;
    var interpolate = d3.interpolate(this._current, d);
    this._current = interpolate(0);
    return function(t) {
      var d2 = interpolate(t);
      return midAngle(d2) < Math.PI ? "start":"end";
    };
  });

text.exit().remove();

//创建提示线条
svg.append("g").attr("class", "lines").attr("transform","translate("+w / 2+","+h / 2+")");
var polyline = svg.select(".lines").selectAll("polyline").data(pie(dataset));
function midAngle(d){
	return d.startAngle + (d.endAngle - d.startAngle)/2;
}
polyline.enter().append("polyline");

polyline.transition().duration(1000).attrTween("points", function(d){
	this._current = this._current || d;
	var interpolate = d3.interpolate(this._current, d);
	this._current = interpolate(0);
	return function(t) {
		var d2 = interpolate(t);
		var pos = outerArc.centroid(d2);
		pos[0] = outerRadius * 0.9 * (midAngle(d2) < Math.PI ? 1 : -1);
		return [arc2.centroid(d2), outerArc.centroid(d2), pos];
	};			
}).style("opacity", .4)

polyline.exit().remove();
</script>
</body>  
</html>